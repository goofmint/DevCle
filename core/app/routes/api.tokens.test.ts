/**
 * API Tokens Route Tests (Task 8.16)
 *
 * Tests for GET /api/tokens endpoint.
 * Verifies authentication, query parameter validation, and response format.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { loader } from './api.tokens.js';
import { runInTenant } from '../../db/tenant-test-utils.js';
import * as schema from '../../db/schema/index.js';
import { sessionStorage, commitSession } from '../sessions.server.js';
import { eq } from 'drizzle-orm';

describe('GET /api/tokens', () => {
  const TEST_TENANT = 'default';
  // Seed data creates a user (test@example.com) in 'default' tenant
  // We need to query this user ID dynamically since it's generated by seed script
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
    });
  });

  /**
   * Helper to create authenticated request
   */
  async function createAuthenticatedRequest(url: string): Promise<Request> {
    const session = await sessionStorage.getSession();
    session.set('userId', testUserId);
    session.set('tenantId', TEST_TENANT);
    const cookieHeader = await commitSession(session);

    return new Request(url, {
      method: 'GET',
      headers: {
        Cookie: cookieHeader,
      },
    });
  }

  it('should return 401 when not authenticated', async () => {
    const request = new Request('http://localhost/api/tokens', {
      method: 'GET',
    });

    const response = await loader({ request, params: {}, context: {} });
    const json = await response.json();

    expect(response.status).toBe(401);
    expect('error' in json).toBe(true);
    if ('error' in json) {
      expect(json.error).toBe('Unauthorized');
    }
  });

  it('should return empty list when no tokens exist', async () => {
    const request = await createAuthenticatedRequest('http://localhost/api/tokens?status=all');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('items' in json).toBe(true);
    if ('items' in json) {
      expect(json.items).toEqual([]);
      expect(json.total).toBe(0);
      expect(json.page).toBe(1);
      expect(json.perPage).toBe(20);
    }
  });

  it('should return active tokens by default', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values([
        {
          tenantId: TEST_TENANT,
          name: 'Active Token',
          tokenPrefix: 'drowltok_ACTIVE1',
          tokenHash: 'hash1',
          scopes: ['webhook:write'],
          createdBy: testUserId,
        },
        {
          tenantId: TEST_TENANT,
          name: 'Revoked Token',
          tokenPrefix: 'drowltok_REVOKE',
          tokenHash: 'hash2',
          scopes: [],
          createdBy: testUserId,
          revokedAt: new Date(),
        },
      ]);
    });

    const request = await createAuthenticatedRequest('http://localhost/api/tokens');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('items' in json).toBe(true);
    if ('items' in json) {
      expect(json.items).toHaveLength(1);
      expect(json.items[0]?.name).toBe('Active Token');
      expect(json.items[0]?.status).toBe('active');
    }
  });

  it('should handle pagination query parameters', async () => {
    const request = await createAuthenticatedRequest('http://localhost/api/tokens?page=2&perPage=10');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('page' in json).toBe(true);
    if ('page' in json && 'perPage' in json) {
      expect(json.page).toBe(2);
      expect(json.perPage).toBe(10);
    }
  });
});
