/**
 * API Tokens Route Tests (Task 8.16 & 8.17)
 *
 * Tests for API token management endpoints:
 * - GET /api/tokens - List tokens (Task 8.16)
 * - POST /api/tokens - Create token (Task 8.17)
 *
 * Verifies authentication, query parameter validation, request body validation,
 * and response format.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { loader, action } from './api.tokens.js';
import { runInTenant } from '../../db/tenant-test-utils.js';
import * as schema from '../../db/schema/index.js';
import { sessionStorage, commitSession } from '../sessions.server.js';
import { eq } from 'drizzle-orm';

describe('GET /api/tokens', () => {
  const TEST_TENANT = 'default';
  // Seed data creates a user (test@example.com) in 'default' tenant
  // We need to query this user ID dynamically since it's generated by seed script
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
    });
  });

  /**
   * Helper to create authenticated request
   */
  async function createAuthenticatedRequest(url: string): Promise<Request> {
    const session = await sessionStorage.getSession();
    session.set('userId', testUserId);
    session.set('tenantId', TEST_TENANT);
    const cookieHeader = await commitSession(session);

    return new Request(url, {
      method: 'GET',
      headers: {
        Cookie: cookieHeader,
      },
    });
  }

  it('should return 401 when not authenticated', async () => {
    const request = new Request('http://localhost/api/tokens', {
      method: 'GET',
    });

    const response = await loader({ request, params: {}, context: {} });
    const json = await response.json();

    expect(response.status).toBe(401);
    expect('error' in json).toBe(true);
    if ('error' in json) {
      expect(json.error).toBe('Unauthorized');
    }
  });

  it('should return empty list when no tokens exist', async () => {
    const request = await createAuthenticatedRequest('http://localhost/api/tokens?status=all');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('items' in json).toBe(true);
    if ('items' in json) {
      expect(json.items).toEqual([]);
      expect(json.total).toBe(0);
      expect(json.page).toBe(1);
      expect(json.perPage).toBe(20);
    }
  });

  it('should return active tokens by default', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values([
        {
          tenantId: TEST_TENANT,
          name: 'Active Token',
          tokenPrefix: 'drowltok_ACTIVE1',
          tokenHash: 'hash1',
          scopes: ['webhook:write'],
          createdBy: testUserId,
        },
        {
          tenantId: TEST_TENANT,
          name: 'Revoked Token',
          tokenPrefix: 'drowltok_REVOKE',
          tokenHash: 'hash2',
          scopes: [],
          createdBy: testUserId,
          revokedAt: new Date(),
        },
      ]);
    });

    const request = await createAuthenticatedRequest('http://localhost/api/tokens');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('items' in json).toBe(true);
    if ('items' in json) {
      expect(json.items).toHaveLength(1);
      expect(json.items[0]?.name).toBe('Active Token');
      expect(json.items[0]?.status).toBe('active');
    }
  });

  it('should handle pagination query parameters', async () => {
    const request = await createAuthenticatedRequest('http://localhost/api/tokens?page=2&perPage=10');

    const response = await loader({ request, params: {}, context: {} });

    expect(response.status).toBe(200);

    const json = await response.json();
    expect('page' in json).toBe(true);
    if ('page' in json && 'perPage' in json) {
      expect(json.page).toBe(2);
      expect(json.perPage).toBe(10);
    }
  });
});

/**
 * POST /api/tokens Tests (Task 8.17)
 *
 * Verifies token creation endpoint:
 * - Authentication requirement
 * - Request body validation
 * - Successful token creation
 * - Plain text token returned only on creation
 * - Duplicate name rejection
 * - Tenant isolation
 */
describe('POST /api/tokens', () => {
  const TEST_TENANT = 'default';
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
      // Also clean up tenant2 if it exists from previous test runs
      await tx.delete(schema.users).where(eq(schema.users.tenantId, 'tenant2'));
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, 'tenant2'));
      await tx.delete(schema.tenants).where(eq(schema.tenants.tenantId, 'tenant2'));
    });
  });

  /**
   * Helper to create authenticated POST request
   */
  async function createAuthenticatedPostRequest(
    url: string,
    body: object
  ): Promise<Request> {
    const session = await sessionStorage.getSession();
    session.set('userId', testUserId);
    session.set('tenantId', TEST_TENANT);
    const cookieHeader = await commitSession(session);

    return new Request(url, {
      method: 'POST',
      headers: {
        Cookie: cookieHeader,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
  }

  it('should return 401 when not authenticated', async () => {
    const request = new Request('http://localhost/api/tokens', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: 'Test Token',
        scopes: ['webhook:write'],
      }),
    });

    const response = await action({ request, params: {}, context: {} });
    const json = await response.json();

    expect(response.status).toBe(401);
    expect('error' in json).toBe(true);
    if ('error' in json) {
      expect(json.error).toBe('Unauthorized');
    }
  });

  it('should create token successfully with required fields', async () => {
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Test Token',
      scopes: ['webhook:write'],
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(201);

    const json = await response.json();
    expect('tokenId' in json).toBe(true);
    if (
      'tokenId' in json &&
      'name' in json &&
      'token' in json &&
      'tokenPrefix' in json &&
      'scopes' in json
    ) {
      expect(json.name).toBe('Test Token');
      expect(json.scopes).toEqual(['webhook:write']);
      expect(json.tokenId).toMatch(/^[0-9a-f-]{36}$/); // UUID format
      expect(json.token).toMatch(/^drowltok_[A-Za-z0-9_-]{32}$/);
      expect(json.tokenPrefix).toBe(json.token.substring(0, 16));
    }
  });

  it('should return plain text token on creation', async () => {
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Token with Plain Text',
      scopes: ['webhook:write'],
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(201);

    const json = await response.json();
    expect('token' in json).toBe(true);
    if ('token' in json) {
      // Plain text token should be returned
      expect(json.token).toBeTruthy();
      expect(json.token).toMatch(/^drowltok_/);
      expect(json.token.length).toBe(41);
    }
  });

  it('should create token with expiration date', async () => {
    const expiresAt = '2099-12-31T23:59:59Z';
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Expiring Token',
      scopes: ['webhook:write'],
      expiresAt,
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(201);

    const json = await response.json();
    expect('expiresAt' in json).toBe(true);
    if ('expiresAt' in json) {
      // Should be ISO 8601 date string
      expect(json.expiresAt).toBeTruthy();
    }
  });

  it('should return all required fields in response', async () => {
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Full Response Test',
      scopes: ['webhook:write'],
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(201);

    const json = await response.json();
    // Verify all expected fields are present
    expect('tokenId' in json).toBe(true);
    expect('name' in json).toBe(true);
    expect('token' in json).toBe(true);
    expect('tokenPrefix' in json).toBe(true);
    expect('scopes' in json).toBe(true);
    expect('expiresAt' in json).toBe(true);
    expect('createdAt' in json).toBe(true);
    expect('createdBy' in json).toBe(true);
  });

  it('should reject request without body', async () => {
    const session = await sessionStorage.getSession();
    session.set('userId', testUserId);
    session.set('tenantId', TEST_TENANT);
    const cookieHeader = await commitSession(session);

    const request = new Request('http://localhost/api/tokens', {
      method: 'POST',
      headers: {
        Cookie: cookieHeader,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({}),
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(400);
  });

  it('should reject empty name', async () => {
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: '',
      scopes: ['webhook:write'],
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(400);
    const json = await response.json();
    expect('error' in json).toBe(true);
  });

  it('should reject empty scopes array', async () => {
    const request = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'No Scopes',
      scopes: [],
    });

    const response = await action({ request, params: {}, context: {} });

    expect(response.status).toBe(400);
    const json = await response.json();
    expect('error' in json).toBe(true);
  });

  it('should reject duplicate name in same tenant', async () => {
    // Create first token
    const request1 = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Duplicate Name',
      scopes: ['webhook:write'],
    });

    const response1 = await action({ request: request1, params: {}, context: {} });
    expect(response1.status).toBe(201);

    // Attempt to create second token with same name
    const request2 = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Duplicate Name',
      scopes: ['webhook:write'],
    });

    const response2 = await action({ request: request2, params: {}, context: {} });
    expect(response2.status).toBe(400);

    const json = await response2.json();
    expect('error' in json).toBe(true);
    if ('error' in json) {
      expect(json.error).toContain('already exists');
    }
  });

  it('should allow same name in different tenants (tenant isolation)', async () => {
    // Create token in 'default' tenant
    const request1 = await createAuthenticatedPostRequest('http://localhost/api/tokens', {
      name: 'Cross-Tenant Token',
      scopes: ['webhook:write'],
    });

    const response1 = await action({ request: request1, params: {}, context: {} });
    expect(response1.status).toBe(201);

    // Create second test tenant and user
    const TEST_TENANT_2 = 'tenant2';
    let testUserId2 = '';

    // First, create the tenant2 in the tenants table
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.tenants).values({
        tenantId: TEST_TENANT_2,
        name: 'Tenant 2',
      });
    });

    await runInTenant(TEST_TENANT_2, async (tx) => {
      // Create user in tenant2
      const [user] = await tx
        .insert(schema.users)
        .values({
          tenantId: TEST_TENANT_2,
          email: 'user2@example.com',
          passwordHash: 'hash',
          displayName: 'User 2',
        })
        .returning();
      testUserId2 = user?.userId ?? '';
    });

    // Create authenticated request for tenant2
    const session2 = await sessionStorage.getSession();
    session2.set('userId', testUserId2);
    session2.set('tenantId', TEST_TENANT_2);
    const cookieHeader2 = await commitSession(session2);

    const request2 = new Request('http://localhost/api/tokens', {
      method: 'POST',
      headers: {
        Cookie: cookieHeader2,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: 'Cross-Tenant Token',
        scopes: ['webhook:write'],
      }),
    });

    const response2 = await action({ request: request2, params: {}, context: {} });
    expect(response2.status).toBe(201);

    // Both tokens should exist
    const json1 = await response1.json();
    const json2 = await response2.json();
    if ('tokenId' in json1 && 'tokenId' in json2) {
      expect(json1.tokenId).not.toBe(json2.tokenId);
    }
  });
});
