/**
 * Campaign Service - Create Operation
 *
 * Handles creation of new campaigns.
 */

import { withTenantContext } from '../db/connection.js';
import * as schema from '../db/schema/index.js';
import {
  CreateCampaignSchema,
  type CreateCampaignInput,
  type CreateCampaignData,
} from './campaign.schemas.js';

/**
 * Create a new campaign
 *
 * @param tenantId - Tenant ID for multi-tenant isolation (required for RLS)
 * @param data - Raw/unvalidated campaign data (z.input type)
 * @returns Created campaign record
 * @throws {Error} If validation fails or database error occurs
 *
 * Implementation details:
 * 1. Validate input using CreateCampaignSchema.parse(data)
 *    - This converts z.input → z.infer (applies defaults)
 * 2. Generate UUID for campaign_id
 * 3. Insert into campaigns table using Drizzle ORM
 * 4. Return inserted record
 *
 * Example usage:
 * ```typescript
 * // Caller passes raw input (no defaults applied)
 * const result = await createCampaign('default', {
 *   name: 'Q4 Product Launch',
 *   channel: 'event',
 *   startDate: new Date('2025-10-01'),
 *   endDate: new Date('2025-12-31'),
 *   budgetTotal: '1000000',
 *   attributes: { utm_source: 'twitter', owner: 'alice' },
 * });
 * ```
 *
 * RLS: Requires app.current_tenant_id to be set in session
 */
export async function createCampaign(
  tenantId: string,
  data: CreateCampaignInput
): Promise<typeof schema.campaigns.$inferSelect> {
  // 1. Validate input data
  // This transforms z.input → z.infer (applies defaults: attributes={})
  const validated: CreateCampaignData = CreateCampaignSchema.parse(data);

  // 2. Execute within transaction with tenant context (production-safe with connection pooling)
  return await withTenantContext(tenantId, async (tx) => {
    try {
      // 3. Prepare values for insertion
      // Build insert object explicitly to ensure correct types
      // PostgreSQL date type expects string in 'YYYY-MM-DD' format
      const insertValues = {
        tenantId: tenantId,
        name: validated.name,
        channel: validated.channel,
        startDate: validated.startDate
          ? validated.startDate.toISOString().split('T')[0]
          : null,
        endDate: validated.endDate
          ? validated.endDate.toISOString().split('T')[0]
          : null,
        budgetTotal: validated.budgetTotal,
        attributes: validated.attributes,
      };

      // 4. Insert into database using Drizzle ORM
      // RLS policy will automatically filter by tenant_id
      // campaignId is auto-generated by database (uuid_generate_v4())
      const [result] = await tx
        .insert(schema.campaigns)
        .values(insertValues)
        .returning();

      // 5. Return created record
      // TypeScript ensures result exists because .returning() always returns array
      if (!result) {
        throw new Error('Failed to create campaign: No record returned');
      }

      return result;
    } catch (error) {
      // Handle database-specific errors
      if (error instanceof Error) {
        // Check for unique constraint violation (duplicate name within tenant)
        // DrizzleQueryError wraps PostgresError in 'cause' property
        const errorMessage = error.message;
        const causeMessage =
          'cause' in error &&
          error.cause instanceof Error
            ? error.cause.message
            : '';

        if (
          errorMessage.includes('duplicate key') ||
          errorMessage.includes('campaigns_tenant_name_unique') ||
          errorMessage.includes('campaigns_tenant_id_name_key') ||
          causeMessage.includes('duplicate key') ||
          causeMessage.includes('campaigns_tenant_name_unique') ||
          causeMessage.includes('campaigns_tenant_id_name_key')
        ) {
          throw new Error('Campaign with this name already exists');
        }
      }

      // Log unexpected errors for debugging
      console.error('Failed to create campaign:', error);
      throw new Error('Failed to create campaign due to database error');
    }
  });
}
