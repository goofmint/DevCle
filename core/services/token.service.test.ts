/**
 * Token Service Tests (Task 8.16 & 8.17)
 *
 * Tests for token management functions:
 * - generateToken(), hashToken(), createToken() (Task 8.17)
 * - listTokens() (Task 8.16)
 *
 * Tests verify token generation, hashing, creation, pagination,
 * status filtering, and status computation.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  generateToken,
  hashToken,
  createToken,
  listTokens,
  getToken,
} from './token.service.js';
import { runInTenant } from '../db/tenant-test-utils.js';
import * as schema from '../db/schema/index.js';
import { eq } from 'drizzle-orm';
import crypto from 'crypto';

/**
 * Test suite for generateToken() (Task 8.17)
 *
 * Verifies cryptographically secure token generation:
 * - Token format: drowltok_<32 random characters>
 * - URL-safe characters only (base64url)
 * - Uniqueness across multiple calls
 */
describe('Token Service - generateToken()', () => {
  it('should generate token with drowltok_ prefix', () => {
    const token = generateToken();
    expect(token).toMatch(/^drowltok_/);
  });

  it('should generate token with exactly 41 characters', () => {
    const token = generateToken();
    expect(token).toHaveLength(41); // 9 (prefix) + 32 (random) = 41
  });

  it('should generate unique tokens on multiple calls', () => {
    const tokens = new Set<string>();
    // Generate 100 tokens and verify they are all unique
    for (let i = 0; i < 100; i++) {
      tokens.add(generateToken());
    }
    expect(tokens.size).toBe(100);
  });

  it('should use only base64url-safe characters', () => {
    const token = generateToken();
    // base64url characters: A-Za-z0-9_-
    // Format: drowltok_<32 base64url chars>
    expect(token).toMatch(/^drowltok_[A-Za-z0-9_-]{32}$/);
  });
});

/**
 * Test suite for hashToken() (Task 8.17)
 *
 * Verifies SHA256 hashing:
 * - Correct hash length (64 hex characters)
 * - Idempotency (same input -> same hash)
 * - Different inputs produce different hashes
 */
describe('Token Service - hashToken()', () => {
  it('should generate SHA256 hash with 64 hex characters', () => {
    const token = 'drowltok_test123456789012345678901';
    const hash = hashToken(token);
    expect(hash).toHaveLength(64);
    expect(hash).toMatch(/^[a-f0-9]{64}$/);
  });

  it('should produce same hash for same input (idempotent)', () => {
    const token = 'drowltok_test123456789012345678901';
    const hash1 = hashToken(token);
    const hash2 = hashToken(token);
    expect(hash1).toBe(hash2);
  });

  it('should produce different hashes for different inputs', () => {
    const token1 = 'drowltok_test1';
    const token2 = 'drowltok_test2';
    const hash1 = hashToken(token1);
    const hash2 = hashToken(token2);
    expect(hash1).not.toBe(hash2);
  });

  it('should match native crypto.createHash output', () => {
    const token = 'drowltok_test123456789012345678901';
    const expected = crypto.createHash('sha256').update(token).digest('hex');
    const actual = hashToken(token);
    expect(actual).toBe(expected);
  });
});

/**
 * Test suite for createToken() (Task 8.17)
 *
 * Verifies token creation and database storage:
 * - Normal creation with required fields
 * - Creation with optional expiresAt
 * - Plain text token returned only on creation
 * - Token prefix stored (first 16 chars)
 * - Token hash stored (not plain text)
 * - Creator recorded
 * - Error handling (duplicate name, validation errors)
 * - Tenant isolation
 */
describe('Token Service - createToken()', () => {
  const TEST_TENANT = 'default';
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up existing tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
      // Also clean up tenant2 if it exists from previous test runs
      await tx.delete(schema.users).where(eq(schema.users.tenantId, 'tenant2'));
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, 'tenant2'));
      await tx.delete(schema.tenants).where(eq(schema.tenants.tenantId, 'tenant2'));
    });
  });

  it('should create token with required fields only', async () => {
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Test Token',
      scopes: ['webhook:write'],
    });

    expect(result.name).toBe('Test Token');
    expect(result.scopes).toEqual(['webhook:write']);
    expect(result.tokenId).toMatch(/^[0-9a-f-]{36}$/); // UUID format
    expect(result.token).toMatch(/^drowltok_[A-Za-z0-9_-]{32}$/);
    expect(result.tokenPrefix).toBe(result.token.substring(0, 16));
    expect(result.expiresAt).toBeNull();
    expect(result.createdBy).toBe(testUserId);
    expect(result.createdAt).toBeInstanceOf(Date);
  });

  it('should create token with expiration date', async () => {
    const expiresAt = new Date('2099-12-31T23:59:59Z');
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Expiring Token',
      scopes: ['webhook:write'],
      expiresAt,
    });

    expect(result.expiresAt).toEqual(expiresAt);
  });

  it('should return plain text token on creation', async () => {
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Token with Plain Text',
      scopes: ['webhook:write'],
    });

    // Plain text token should be returned
    expect(result.token).toBeTruthy();
    expect(result.token).toMatch(/^drowltok_/);
    expect(result.token).toHaveLength(41);
  });

  it('should store token prefix (first 16 characters)', async () => {
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Token Prefix Test',
      scopes: ['webhook:write'],
    });

    // Token prefix should be first 16 characters
    expect(result.tokenPrefix).toBe(result.token.substring(0, 16));
    expect(result.tokenPrefix).toHaveLength(16);

    // Verify it's stored in database
    await runInTenant(TEST_TENANT, async (tx) => {
      const [stored] = await tx
        .select()
        .from(schema.apiTokens)
        .where(eq(schema.apiTokens.tokenId, result.tokenId));

      expect(stored?.tokenPrefix).toBe(result.tokenPrefix);
    });
  });

  it('should store token hash (not plain text)', async () => {
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Token Hash Test',
      scopes: ['webhook:write'],
    });

    // Verify hash is stored in database (not plain text)
    await runInTenant(TEST_TENANT, async (tx) => {
      const [stored] = await tx
        .select()
        .from(schema.apiTokens)
        .where(eq(schema.apiTokens.tokenId, result.tokenId));

      // Hash should be 64 hex characters
      expect(stored?.tokenHash).toMatch(/^[a-f0-9]{64}$/);

      // Hash should match SHA256 of plain text token
      const expectedHash = hashToken(result.token);
      expect(stored?.tokenHash).toBe(expectedHash);

      // Plain text token should NOT be stored
      expect(stored?.tokenHash).not.toBe(result.token);
    });
  });

  it('should record creator (createdBy)', async () => {
    const result = await createToken(TEST_TENANT, testUserId, {
      name: 'Creator Test',
      scopes: ['webhook:write'],
    });

    expect(result.createdBy).toBe(testUserId);

    // Verify in database
    await runInTenant(TEST_TENANT, async (tx) => {
      const [stored] = await tx
        .select()
        .from(schema.apiTokens)
        .where(eq(schema.apiTokens.tokenId, result.tokenId));

      expect(stored?.createdBy).toBe(testUserId);
    });
  });

  it('should reject duplicate name in same tenant', async () => {
    // Create first token
    await createToken(TEST_TENANT, testUserId, {
      name: 'Duplicate Name',
      scopes: ['webhook:write'],
    });

    // Attempt to create second token with same name
    await expect(
      createToken(TEST_TENANT, testUserId, {
        name: 'Duplicate Name',
        scopes: ['webhook:write'],
      })
    ).rejects.toThrow('Token name already exists');
  });

  it('should reject empty name', async () => {
    await expect(
      createToken(TEST_TENANT, testUserId, {
        name: '',
        scopes: ['webhook:write'],
      })
    ).rejects.toThrow();
  });

  it('should reject empty scopes array', async () => {
    await expect(
      createToken(TEST_TENANT, testUserId, {
        name: 'No Scopes',
        scopes: [],
      })
    ).rejects.toThrow();
  });

  it('should allow same name in different tenants (tenant isolation)', async () => {
    // Create token in 'default' tenant
    const token1 = await createToken(TEST_TENANT, testUserId, {
      name: 'Cross-Tenant Token',
      scopes: ['webhook:write'],
    });

    // Create second test tenant and user
    const TEST_TENANT_2 = 'tenant2';
    let testUserId2 = '';

    // First, create the tenant2 in the tenants table
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.tenants).values({
        tenantId: TEST_TENANT_2,
        name: 'Tenant 2',
      });
    });

    await runInTenant(TEST_TENANT_2, async (tx) => {
      // Create user in tenant2
      const [user] = await tx
        .insert(schema.users)
        .values({
          userId: crypto.randomUUID(),
          tenantId: TEST_TENANT_2,
          email: 'user2@example.com',
          passwordHash: 'hash',
          displayName: 'User 2',
        })
        .returning();
      testUserId2 = user?.userId ?? '';
    });

    // Create token with same name in 'tenant2'
    const token2 = await createToken(TEST_TENANT_2, testUserId2, {
      name: 'Cross-Tenant Token',
      scopes: ['webhook:write'],
    });

    // Both tokens should exist with different IDs
    expect(token1.tokenId).not.toBe(token2.tokenId);
    expect(token1.name).toBe(token2.name);
  });
});

/**
 * Test suite for getToken() (Task 8.18)
 *
 * Verifies token detail retrieval:
 * - Returns token with computed status (active/expired/revoked)
 * - Excludes tokenHash from response (security requirement)
 * - Throws error for non-existent tokens
 * - Enforces RLS tenant isolation
 */
describe('Token Service - getToken()', () => {
  const TEST_TENANT = 'default';
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up existing tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
      // Also clean up tenant2 if it exists from previous test runs
      await tx.delete(schema.users).where(eq(schema.users.tenantId, 'tenant2'));
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, 'tenant2'));
      await tx.delete(schema.tenants).where(eq(schema.tenants.tenantId, 'tenant2'));
    });
  });

  it('should return token detail with status "active"', async () => {
    // Create active token (no expiration, not revoked)
    const token = await createToken(TEST_TENANT, testUserId, {
      name: 'Active Token',
      scopes: ['webhook:write'],
    });

    // Get token detail
    const result = await getToken(TEST_TENANT, token.tokenId);

    // Verify response
    expect(result.tokenId).toBe(token.tokenId);
    expect(result.name).toBe('Active Token');
    expect(result.tokenPrefix).toBe(token.tokenPrefix);
    expect(result.scopes).toEqual(['webhook:write']);
    expect(result.status).toBe('active');
    expect(result.expiresAt).toBeNull();
    expect(result.revokedAt).toBeNull();
    expect(result.createdBy).toBe(testUserId);

    // Verify tokenHash is NOT included (security requirement)
    expect(result).not.toHaveProperty('tokenHash');
  });

  it('should return token detail with status "expired"', async () => {
    // Create expired token (expires_at in the past)
    const token = await createToken(TEST_TENANT, testUserId, {
      name: 'Expired Token',
      scopes: ['webhook:write'],
      expiresAt: new Date('2020-01-01'), // Past date
    });

    // Get token detail
    const result = await getToken(TEST_TENANT, token.tokenId);

    // Verify response
    expect(result.tokenId).toBe(token.tokenId);
    expect(result.name).toBe('Expired Token');
    expect(result.status).toBe('expired');
    expect(result.revokedAt).toBeNull();

    // Verify tokenHash is NOT included
    expect(result).not.toHaveProperty('tokenHash');
  });

  it('should return token detail with status "revoked"', async () => {
    // Create token and then revoke it
    const token = await createToken(TEST_TENANT, testUserId, {
      name: 'Revoked Token',
      scopes: ['webhook:write'],
    });

    // Manually revoke token in database
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx
        .update(schema.apiTokens)
        .set({ revokedAt: new Date() })
        .where(eq(schema.apiTokens.tokenId, token.tokenId));
    });

    // Get token detail
    const result = await getToken(TEST_TENANT, token.tokenId);

    // Verify response
    expect(result.tokenId).toBe(token.tokenId);
    expect(result.name).toBe('Revoked Token');
    expect(result.status).toBe('revoked');
    expect(result.revokedAt).not.toBeNull();

    // Verify tokenHash is NOT included
    expect(result).not.toHaveProperty('tokenHash');
  });

  it('should throw error if token not found', async () => {
    // Try to get non-existent token
    const fakeTokenId = crypto.randomUUID();

    await expect(getToken(TEST_TENANT, fakeTokenId)).rejects.toThrow(
      'Token not found'
    );
  });

  it('should not return tokens from other tenants (RLS)', async () => {
    // Create token in 'default' tenant
    const token = await createToken(TEST_TENANT, testUserId, {
      name: 'Tenant1 Token',
      scopes: ['webhook:write'],
    });

    // Create second test tenant
    const TEST_TENANT_2 = 'tenant2';

    // First, create the tenant2 in the tenants table
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.tenants).values({
        tenantId: TEST_TENANT_2,
        name: 'Tenant 2',
      });
    });

    // Try to get token from tenant2 (should fail due to RLS)
    await expect(getToken(TEST_TENANT_2, token.tokenId)).rejects.toThrow(
      'Token not found'
    );
  });
});

describe('Token Service - listTokens()', () => {
  const TEST_TENANT = 'default';
  // Seed data creates a user (test@example.com) in 'default' tenant
  // We need to query this user ID dynamically since it's generated by seed script
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up existing tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
    });
  });

  it('should return empty list when no tokens exist', async () => {
    const result = await listTokens(TEST_TENANT, {});

    expect(result.items).toEqual([]);
    expect(result.total).toBe(0);
    expect(result.page).toBe(1);
    expect(result.perPage).toBe(20);
  });

  it('should list active tokens only by default', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      // Create active token
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Active Token',
        tokenPrefix: 'drowltok_ACTIVE1',
        tokenHash: 'hash1',
        scopes: ['webhook:write'],
        createdBy: testUserId,
        expiresAt: new Date('2099-12-31'),
        revokedAt: null,
      });

      // Create revoked token (should NOT be included in active filter)
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Revoked Token',
        tokenPrefix: 'drowltok_REVOKED',
        tokenHash: 'hash2',
        scopes: ['webhook:write'],
        createdBy: testUserId,
        revokedAt: new Date(),
      });
    });

    const result = await listTokens(TEST_TENANT, {});

    expect(result.items).toHaveLength(1);
    expect(result.items[0]?.name).toBe('Active Token');
    expect(result.items[0]?.status).toBe('active');
    expect(result.total).toBe(1);
  });

  it('should filter by status: all', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values([
        {
          tenantId: TEST_TENANT,
          name: 'Token 1',
          tokenPrefix: 'drowltok_TOKEN1',
          tokenHash: 'hash1',
          scopes: [],
          createdBy: testUserId,
        },
        {
          tenantId: TEST_TENANT,
          name: 'Token 2',
          tokenPrefix: 'drowltok_TOKEN2',
          tokenHash: 'hash2',
          scopes: [],
          createdBy: testUserId,
          revokedAt: new Date(),
        },
      ]);
    });

    const result = await listTokens(TEST_TENANT, { status: 'all' });

    expect(result.items).toHaveLength(2);
    expect(result.total).toBe(2);
  });

  it('should apply pagination correctly', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      // Insert 5 tokens
      for (let i = 1; i <= 5; i++) {
        await tx.insert(schema.apiTokens).values({
          tenantId: TEST_TENANT,
          name: `Token ${i}`,
          tokenPrefix: `drowltok_TOKEN${i}`,
          tokenHash: `hash${i}`,
          scopes: [],
          createdBy: testUserId,
        });
      }
    });

    const page1 = await listTokens(TEST_TENANT, { page: 1, perPage: 2 });
    const page2 = await listTokens(TEST_TENANT, { page: 2, perPage: 2 });

    expect(page1.items).toHaveLength(2);
    expect(page1.total).toBe(5);
    expect(page1.page).toBe(1);
    expect(page1.perPage).toBe(2);

    expect(page2.items).toHaveLength(2);
    expect(page2.total).toBe(5);
    expect(page2.page).toBe(2);
  });

  it('should compute status correctly for expired tokens', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Expired Token',
        tokenPrefix: 'drowltok_EXPIRED',
        tokenHash: 'hash_expired',
        scopes: [],
        createdBy: testUserId,
        expiresAt: new Date('2020-01-01'), // Past date
        revokedAt: null,
      });
    });

    const result = await listTokens(TEST_TENANT, { status: 'all' });

    expect(result.items).toHaveLength(1);
    expect(result.items[0]?.status).toBe('expired');
  });
});
