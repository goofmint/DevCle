/**
 * Token Service Tests (Task 8.16)
 *
 * Tests for listTokens() function.
 * Tests verify pagination, status filtering, and status computation.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { listTokens } from './token.service.js';
import { runInTenant } from '../db/tenant-test-utils.js';
import * as schema from '../db/schema/index.js';
import { eq } from 'drizzle-orm';

describe('Token Service - listTokens()', () => {
  const TEST_TENANT = 'default';
  // Seed data creates a user (test@example.com) in 'default' tenant
  // We need to query this user ID dynamically since it's generated by seed script
  let testUserId: string;

  beforeEach(async () => {
    // Get test user ID from database (dynamically, as it's generated by seed)
    await runInTenant(TEST_TENANT, async (tx) => {
      const users = await tx
        .select()
        .from(schema.users)
        .where(eq(schema.users.email, 'test@example.com'))
        .limit(1);
      testUserId = users[0]?.userId ?? '';
    });

    if (!testUserId) {
      throw new Error('Test user not found in database');
    }

    // Clean up existing tokens before each test
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.delete(schema.apiTokens).where(eq(schema.apiTokens.tenantId, TEST_TENANT));
    });
  });

  it('should return empty list when no tokens exist', async () => {
    const result = await listTokens(TEST_TENANT, {});

    expect(result.items).toEqual([]);
    expect(result.total).toBe(0);
    expect(result.page).toBe(1);
    expect(result.perPage).toBe(20);
  });

  it('should list active tokens only by default', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      // Create active token
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Active Token',
        tokenPrefix: 'drowltok_ACTIVE1',
        tokenHash: 'hash1',
        scopes: ['webhook:write'],
        createdBy: testUserId,
        expiresAt: new Date('2099-12-31'),
        revokedAt: null,
      });

      // Create revoked token (should NOT be included in active filter)
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Revoked Token',
        tokenPrefix: 'drowltok_REVOKED',
        tokenHash: 'hash2',
        scopes: ['webhook:write'],
        createdBy: testUserId,
        revokedAt: new Date(),
      });
    });

    const result = await listTokens(TEST_TENANT, {});

    expect(result.items).toHaveLength(1);
    expect(result.items[0]?.name).toBe('Active Token');
    expect(result.items[0]?.status).toBe('active');
    expect(result.total).toBe(1);
  });

  it('should filter by status: all', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values([
        {
          tenantId: TEST_TENANT,
          name: 'Token 1',
          tokenPrefix: 'drowltok_TOKEN1',
          tokenHash: 'hash1',
          scopes: [],
          createdBy: testUserId,
        },
        {
          tenantId: TEST_TENANT,
          name: 'Token 2',
          tokenPrefix: 'drowltok_TOKEN2',
          tokenHash: 'hash2',
          scopes: [],
          createdBy: testUserId,
          revokedAt: new Date(),
        },
      ]);
    });

    const result = await listTokens(TEST_TENANT, { status: 'all' });

    expect(result.items).toHaveLength(2);
    expect(result.total).toBe(2);
  });

  it('should apply pagination correctly', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      // Insert 5 tokens
      for (let i = 1; i <= 5; i++) {
        await tx.insert(schema.apiTokens).values({
          tenantId: TEST_TENANT,
          name: `Token ${i}`,
          tokenPrefix: `drowltok_TOKEN${i}`,
          tokenHash: `hash${i}`,
          scopes: [],
          createdBy: testUserId,
        });
      }
    });

    const page1 = await listTokens(TEST_TENANT, { page: 1, perPage: 2 });
    const page2 = await listTokens(TEST_TENANT, { page: 2, perPage: 2 });

    expect(page1.items).toHaveLength(2);
    expect(page1.total).toBe(5);
    expect(page1.page).toBe(1);
    expect(page1.perPage).toBe(2);

    expect(page2.items).toHaveLength(2);
    expect(page2.total).toBe(5);
    expect(page2.page).toBe(2);
  });

  it('should compute status correctly for expired tokens', async () => {
    await runInTenant(TEST_TENANT, async (tx) => {
      await tx.insert(schema.apiTokens).values({
        tenantId: TEST_TENANT,
        name: 'Expired Token',
        tokenPrefix: 'drowltok_EXPIRED',
        tokenHash: 'hash_expired',
        scopes: [],
        createdBy: testUserId,
        expiresAt: new Date('2020-01-01'), // Past date
        revokedAt: null,
      });
    });

    const result = await listTokens(TEST_TENANT, { status: 'all' });

    expect(result.items).toHaveLength(1);
    expect(result.items[0]?.status).toBe('expired');
  });
});
