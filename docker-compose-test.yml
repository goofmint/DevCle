# docker-compose-test.yml (E2E Test environment)
# Note: Use Compose V2 (docker compose)
# Usage: docker compose -f docker-compose.yml -f docker-compose-test.yml up -d
version: '3.9'

services:
  nginx:
    volumes:
      # Override SSL certificate files for test (devcle.test)
      # Certificate file (test domain)
      - ./certs/devcle.test+3.pem:/etc/nginx/certs/server.crt:ro
      # Private key file (test domain)
      - ./certs/devcle.test+3-key.pem:/etc/nginx/certs/server.key:ro

  core:
    build:
      # Use development target for test environment
      target: development
      # Use the same Dockerfile as production but different target
      dockerfile: ../docker/Dockerfile.core
    environment:
      # Override NODE_ENV for test
      NODE_ENV: test
      # Set CI flag for non-interactive pnpm install
      CI: "true"
      # PostgreSQL environment variables for drizzle-kit (test database)
      POSTGRES_DB: ${POSTGRES_TEST_DB:-devcle_test}
      POSTGRES_USER: ${POSTGRES_USER:-devcle}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      # Database host points to postgres service in docker network
      DATABASE_HOST: postgres
      # Override DATABASE_URL for test database
      DATABASE_URL: postgresql://${POSTGRES_USER:-devcle}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_TEST_DB:-devcle_test}
      # Encryption key for sensitive data
      ENCRYPTION_KEY: ${ENCRYPTION_KEY}
      # Redis connection for session storage
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379
      # Session secret for authentication
      SESSION_SECRET: ${SESSION_SECRET}
    volumes:
      # Mount source code for test access from core directory
      - ./core:/app
      # Use named volume to preserve container's node_modules (Linux Alpine binaries)
      # This prevents macOS host binaries from being used in Linux container
      - core-node-modules-test:/app/node_modules
    ports:
      # Expose test server for Playwright access
      - "3000:3000"
    # Override command to install dependencies and run development server
    # This ensures Linux Alpine binaries are used instead of macOS host binaries
    command: sh -c "pnpm install --frozen-lockfile && pnpm dev"

  # PostgreSQL service for test environment
  # Uses separate database from development
  postgres:
    image: postgres:15-alpine
    container_name: devcle-postgres-test
    environment:
      # Test database name (defaults to 'devcle_test' if not set)
      POSTGRES_DB: ${POSTGRES_TEST_DB:-devcle_test}
      # Database user (defaults to 'devcle' if not set)
      POSTGRES_USER: ${POSTGRES_USER:-devcle}
      # Database password (must be set in .env)
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      # Persist test database data using named volume
      - postgres-data-test:/var/lib/postgresql/data
      # Mount initialization script (read-only, executable)
      # Uses .sh for environment variable interpolation and persistent timezone setting
      - ./infra/postgres/init.sh:/docker-entrypoint-initdb.d/01-init.sh:ro
      # Mount RLS policies script (read-only)
      # Applies Row Level Security policies for multi-tenant data isolation
      - ./infra/postgres/rls.sql:/docker-entrypoint-initdb.d/02-rls.sql:ro
    networks:
      - devcle-network
    restart: unless-stopped
    ports:
      # Expose postgres port on different port to avoid conflict with dev DB
      - "5433:5432"
    healthcheck:
      # Check if PostgreSQL is ready to accept connections
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-devcle}"]
      interval: 10s
      timeout: 5s
      retries: 5
      # Allow 30s for postgres to boot before starting healthchecks
      start_period: 30s

  # Redis service for test environment
  # Uses separate instance from development
  redis:
    # Redis 7.x Alpine image for cache, session storage, and job queue (BullMQ)
    image: redis:7-alpine
    container_name: devcle-redis-test
    environment:
      # Redis password for authentication (required)
      REDIS_PASSWORD: ${REDIS_PASSWORD}
    # Override requirepass in redis.conf with environment variable
    # This allows dynamic password configuration without modifying redis.conf
    command: >
      redis-server /usr/local/etc/redis/redis.conf
      --requirepass ${REDIS_PASSWORD}
    volumes:
      # Mount redis configuration (read-only)
      # Configuration includes: memory limits, AOF persistence, security settings
      - ./infra/redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
      # Persist redis data using named volume for AOF files
      - redis-data-test:/data
    networks:
      - devcle-network
    restart: unless-stopped
    ports:
      # Expose redis port on different port to avoid conflict with dev Redis
      - "6380:6379"
    healthcheck:
      # Verify Redis is ready to accept connections with password authentication
      # Uses PING command which returns PONG when authenticated
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "PING"]
      interval: 10s
      timeout: 5s
      retries: 5
      # Allow 10s for redis to boot before starting healthchecks
      start_period: 10s

volumes:
  # Named volume for core's node_modules to preserve Linux Alpine binaries (test)
  core-node-modules-test:
  # Named volume for PostgreSQL data persistence in test
  postgres-data-test:
  # Named volume for Redis data persistence in test
  redis-data-test:
